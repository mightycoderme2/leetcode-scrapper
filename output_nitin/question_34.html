<html><head></head><body>
<div id="title">
 34. Find First and Last Position of Element in Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   sorted in ascending order, find the starting and ending position of a given
   <code>
    target
   </code>
   value.
  </p>
  <p>
   If
   <code>
    target
   </code>
   is not found in the array, return
   <code>
    [-1, -1]
   </code>
   .
  </p>
  <p>
   You must write an algorithm with
   <code>
    O(log n)
   </code>
   runtime complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8
<strong>Output:</strong> [3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6
<strong>Output:</strong> [-1,-1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [], target = 0
<strong>Output:</strong> [-1,-1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is a non-decreasing array.
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 34 -->
<pre>/*
 * @lc app=leetcode id=34 lang=cpp
 *
 * [34] Find First and Last Position of Element in Sorted Array
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; a, int target) {

    int start = 0 , end= a.size()-1;
    int left=-1,right=-1;
    while(start &lt;= end)
    {
        int mid=(start+end)/2;
        if(a[mid]&gt;target)
        {
            end=mid-1;
        }
        else if(a[mid]&lt;target)
        {
            start=mid+1;
        }
        else
        {
            left=mid;
            end=mid-1;
        }
    }

     start = 0 ;
     end= a.size()-1;
    while(start &lt;= end)
    {
        int mid=(start+end)/2;
        if(a[mid]&gt;target)
        {
            end=mid-1;
        }
        else if(a[mid]&lt;target)
        {
            start=mid+1;
        }
        else
        {
            right=mid;
            start=mid+1;
        }
    }
    return {left,right};
    }
};
// @lc code=end

</pre>