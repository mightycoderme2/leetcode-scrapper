<html><head></head><body>
<div id="title">
 76. Minimum Window Substring
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   of lengths
   <code>
    m
   </code>
   and
   <code>
    n
   </code>
   respectively, return
   <em>
    the
    <strong>
     minimum window substring
    </strong>
    of
   </em>
   <code>
    s
   </code>
   <em>
    such that every character in
   </em>
   <code>
    t
   </code>
   <em>
    (
    <strong>
     including duplicates
    </strong>
    ) is included in the window. If there is no such substring
   </em>
   <em>
    , return the empty string
   </em>
   <code>
    ""
   </code>
   <em>
    .
   </em>
  </p>
  <p>
   The testcases will be generated such that the answer is
   <strong>
    unique
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    substring
   </strong>
   is a contiguous sequence of characters within the string.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ADOBECODEBANC", t = "ABC"
<strong>Output:</strong> "BANC"
<strong>Explanation:</strong> The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a", t = "a"
<strong>Output:</strong> "a"
<strong>Explanation:</strong> The entire string s is the minimum window.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a", t = "aa"
<strong>Output:</strong> ""
<strong>Explanation:</strong> Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == s.length
    </code>
   </li>
   <li>
    <code>
     n == t.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, nÂ &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of uppercase and lowercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you find an algorithm that runs in
  <code>
   O(m + n)
  </code>
  time?
 </div>
</div>
</body></html>
<!-- Solution for Question 76 -->
<pre>/*
 * @lc app=leetcode id=76 lang=cpp
 *
 * [76] Minimum Window Substring
 */

// @lc code=start
class Solution {
public:
/*
int check(string s,string t){
    map&lt;char,int&gt;m1,m2;
    for(int i=0;i&lt;t.length();i++){
        m1[t[i]]++;
    }
    for(int i=0;i&lt;s.length();i++){
        m2[s[i]]++;
    }
    for(auto x : m1)
    {
        if(x.second&gt;m2[x.first])
        {
            return false;
        }
    }
    return true;
}
string val(string s,int start,int end){
    string ans=&quot;&quot;;
    for(int i=start;i&lt;end;i++)
    {
        ans=ans+s[i];
    }
    return ans;
}
    string minWindow(string s, string t) {
         if(s.length() &lt; t.length()) return &quot;&quot;;
        if(s==t) return s;
       if(check(s,t)==0) return &quot;&quot;;
       if(t.length()==1) return t;
       int start=0,end=0;
        string ans=&quot;&quot;,minn=s;
        while(start&lt;=end &amp;&amp; end&lt;=s.length())
        {
            cout&lt;&lt;val(s,start,end)&lt;&lt;&#x27;\n&#x27;;
            if(check(val(s,start,end),t)==0)
            {
                end++;
            }

            else if(check(val(s,start,end),t)==1)
            {
                if(minn.length()&gt;val(s,start,end).length() )
                {
                    minn=val(s,start,end);
                }
                start++;
            }
            cout&lt;&lt;start&lt;&lt;end&lt;&lt;&#x27;\n&#x27;;
        }
        return minn;

    }
};
*/

string minWindow(string s, string t) {
    vector&lt;int&gt;m(128,0);
    for(auto x:t) m[x]++;
    int count=t.size(),start=0,end=0,d=INT_MAX,head=0;
    while(end&lt;s.size()){
        if(m[s[end++]]-- &gt;0) count--;
        while(count==0){
            if(d&gt;end-start){
                head=start;
                d=end-start;
            }
            if(m[s[start++]]++==0) count++;
        }

    }
    return d==INT_MAX?&quot;&quot;:s.substr(head,d);

    }
};
// @lc code=end

</pre>